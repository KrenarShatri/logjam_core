#!/usr/bin/env ruby

$stdout.sync = true
$stderr.sync = true

require File.expand_path('../../../../../config/boot.rb', __FILE__)
require 'em-websocket'
require 'amqp'
require 'set'

@exchanges = {}
@queues = {}
@perf_buffers = Hash.new{|h,k| h[k] = []}
@error_buffers = Hash.new{|h,k| h[k] = []}
@sockets = Hash.new{|h,k| h[k] = Set.new}

def create_queue_and_subscribe(app_env, key)
  exchange = @exchanges[app_env]
  queue_name = "#{app_env}-#{key}-#{`hostname`.chomp}"
  queue = @channel.queue(queue_name, :auto_delete => true, :exclusive => true)
  queue.bind(exchange, :key => key)
  subscribe("#{app_env},#{key}", queue)
  queue
end

def subscribe(app_env_key, queue)
  queue.subscribe do |header, perf_data|
    # $stderr.puts perf_data if perf_data =~ /description/
    b = perf_data =~ /total_time/ ? @perf_buffers[app_env_key] : @error_buffers[app_env_key]
    b << perf_data
    b.shift if b.size > 60
    @sockets[app_env_key].each {|s| s.send perf_data}
  end
end

EventMachine.run do
  @channel = MQ.new(AMQP::connect(:host => "127.0.0.1"))
  EventMachine::WebSocket.start(:host => "0.0.0.0", :port => 8080) do |ws|
    ws.onopen { puts "web socket connection established: #{ws.object_id}" }

    ws.onclose do
      puts "web socket connection closed: #{ws.object_id}"
      @sockets.each_value{|sockets| sockets.delete(ws) }
    end

    ws.onmessage do |app_env_key|
      app_env, key = app_env_key.split(/,/)
      @exchanges[app_env] ||= @channel.topic("logjam-performance-data-#{app_env}")
      @queues[app_env_key] ||= create_queue_and_subscribe(app_env, key)
      @sockets[app_env_key] << ws
      @perf_buffers[app_env_key].each{|m| ws.send m}
      @error_buffers[app_env_key].each{|m| ws.send m}
      puts "web socket subscribed to #{app_env_key}: #{ws.object_id}"
    end
  end
end
